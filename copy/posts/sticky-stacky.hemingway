{"entityMap":{},"blocks":[{"key":"4h06o","text":"Sticky Stacky peeking navigation","type":"header-one","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1edkf","text":"At the time of writing I work at store.google.com. One of our design choices has been for the navigation to scroll with you. As the user scrolls down, one could have the navigation bars stack up. This pattern could fill the screen. Instead, this alternative design only shows the bottom most bar. As the user scrolls up, the navigation bars from above peak out from anywhere on the page.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"7gpsu","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fk52g","text":"This is a common design pattern. As I have fixed bugs with store.google.com's navigation bar, I have reconsidered how complex the setup is. Here, I present a simpler, more general, and scalable way to support such a system.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3kap6","text":"","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"d3sr7","text":"How does it work?","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"6oi5k","text":"At its core, this system is not complex. The markup is basic, as is the styles. The javascript can be challenging to wrap your head around, since it has to keep up with the scroll state.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2qla6","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"222ap","text":"What do you need for the markup? ","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b36of","text":"1) a container that holds the height and position of the navigation bar on the page. 2) the actual visible navigation bar that sticks when scrolling.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bpcfq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eao9l","text":"What do you need for the styles?","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a7pah","text":"For the container element, your styles are simple: a block element that holds the height of your navigation bar. Through some experimenting, I found a good way to smooth rendering, and simplify the javascript. We calculate the height and store it in a CSS variable.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8ifts","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8ltqd","text":"For the navigation bar itself, the styles are still simple. You need a basic default state, and a fixed state. The default state uses `position: relative`. The fixed state moves it to `position: fixed`. The important piece keeps the navigation bars sticking in the right positions.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cdjvq","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"buns8","text":"To keep them sticking in the right positions, we depend on two properties. The `top` property is the sum of the heights of previous navigation bars. Again, I am using a CSS variable for simplicity. The `transform` property uses another CSS variable to translate the nav bar up and down. This translation handles the peaking logic. The CSS variable we use here will be quite dynamic, and updated with JavaScript.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"c7l3j","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ak9cg","text":"The JavaScript that drives the interaction.","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"fgl3a","text":"Breaking the algorithm into two pieces is the most organized. A class that controls all the sticky navigation bars on the page: StickyController. And a class that updates each sticky navigation bar: StickyStacky.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"be4t9","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cndg9","text":"Read through the comments in the JavaScript below. The explanation makes the most sense to me in context.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"725ac","text":"","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"frfmc","text":"Conclusion","type":"header-two","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"el45","text":"I hope this has been a helpful and informative way to combine JavaScript, HTML, and CSS in a robust and scalable way. The patterns I use in this solution are more valuable than the solution itself.","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}]}